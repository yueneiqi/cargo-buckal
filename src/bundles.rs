use std::collections::HashMap;
use std::io::Write;
use std::result::Result::Ok;

use anyhow::Result;
use reqwest::blocking::Client;
use reqwest::header::USER_AGENT;
use serde::Deserialize;

use crate::{buckal_log, buckal_warn, user_agent};

type Section = String;
type Lines = Vec<String>;

#[derive(Default)]
struct BuckConfig {
    section_order: Vec<Section>,
    sections: HashMap<Section, Lines>,
}

impl BuckConfig {
    pub fn load(path: &std::path::Path) -> std::io::Result<Self> {
        let contents = std::fs::read_to_string(path)?;
        Ok(Self::parse(contents))
    }

    pub fn save(&self, path: &std::path::Path) -> std::io::Result<()> {
        std::fs::write(path, self.serialize())?;
        Ok(())
    }

    pub fn get_section_mut(&mut self, section: &str) -> &mut Lines {
        self.sections.entry(section.to_string()).or_default()
    }

    fn new_section_after(&mut self, after_section: &str, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());

        if let Some(pos) = self.section_order.iter().position(|s| s == after_section) {
            self.section_order
                .insert(pos + 1, new_section_name.to_owned());
        } else {
            self.section_order.push(new_section_name.to_owned());
        }

        self.sections.entry(new_section_name).or_default()
    }

    fn new_section(&mut self, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());
        self.section_order.push(new_section_name.to_owned());

        self.sections.entry(new_section_name).or_default()
    }

    fn parse(contents: String) -> BuckConfig {
        let lines: Vec<String> = contents.lines().map(|s| s.to_string()).collect();

        let mut config = BuckConfig::default();
        let mut current_section: Option<String> = None;

        for line in lines {
            let trimmed = line.trim();
            if trimmed.starts_with('[') && trimmed.ends_with(']') {
                let section_name = trimmed[1..trimmed.len() - 1].to_string();
                config.section_order.push(section_name.clone());
                current_section = Some(section_name);
            } else if trimmed.starts_with('#') {
                continue;
            } else if !line.is_empty()
                && let Some(section) = &current_section
            {
                config
                    .sections
                    .entry(section.clone())
                    .or_default()
                    .push(line);
            }
        }
        config
    }

    fn serialize(&self) -> String {
        let mut output = String::new();

        for section in &self.section_order {
            output.push('[');
            output.push_str(section);
            output.push_str("]\n");
            if let Some(lines) = self.sections.get(section) {
                for line in lines {
                    output.push_str(line);
                    output.push('\n');
                }
                output.push('\n');
            }
        }
        output.pop();

        output
    }
}

pub fn init_modifier(dest: &std::path::Path) -> Result<()> {
    let mut package_file = std::fs::File::create(dest.join("PACKAGE"))?;

    writeln!(package_file, "# @generated by `cargo buckal`")?;
    writeln!(package_file)?;
    writeln!(
        package_file,
        "load(\"@prelude//cfg/modifier:set_cfg_modifiers.bzl\", \"set_cfg_modifiers\")"
    )?;
    writeln!(
        package_file,
        "load(\"@prelude//rust:with_workspace.bzl\", \"with_rust_workspace\")"
    )?;
    writeln!(
        package_file,
        "load(\"@buckal//config:set_cfg_constructor.bzl\", \"set_cfg_constructor\")"
    )?;
    writeln!(package_file)?;
    writeln!(package_file, "ALIASES = {{")?;
    writeln!(
        package_file,
        "    \"debug\": \"buckal//config/mode:debug\","
    )?;
    writeln!(
        package_file,
        "    \"release\": \"buckal//config/mode:release\","
    )?;
    writeln!(package_file, "}}")?;
    writeln!(package_file, "set_cfg_constructor(aliases = ALIASES)")?;
    writeln!(package_file)?;
    writeln!(package_file, "set_cfg_modifiers(")?;
    writeln!(package_file, "    cfg_modifiers = [")?;
    writeln!(package_file, "        \"buckal//config/mode:debug\",")?;
    writeln!(package_file, "    ],")?;
    writeln!(package_file, ")")?;

    Ok(())
}

pub fn init_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let cells = buckconfig.get_section_mut("cells");
    upsert_kv_line(cells, "buckal", "buckal");
    let external_cells = buckconfig.get_section_mut("external_cells");
    upsert_kv_line(external_cells, "buckal", "git");
    let buckal_section =
        buckconfig.new_section_after("external_cells", "external_cell_buckal".to_owned());
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    let project = buckconfig.new_section("project".to_owned());
    project.push("  ignore = .git .buckal buck-out target".to_owned());
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

fn upsert_kv_line(lines: &mut Lines, key: &str, value: &str) {
    let prefix = format!("{key} =");
    let replacement = format!("  {key} = {value}");
    if let Some(pos) = lines
        .iter()
        .position(|line| line.trim_start().starts_with(&prefix))
    {
        lines[pos] = replacement;
    } else {
        lines.push(replacement);
    }
}

/// Initialize platform-related skeleton files after `buck2 init`.
///
/// Write a minimal `platforms/BUCK` for common Rust triples so users can pass
/// `--target-platforms` without additional setup.
///
/// We also generate an OS-aware `toolchains/BUCK` to avoid demo toolchain issues
/// and to support Windows builds without requiring manual edits.
pub fn init_platform_files(dest: &std::path::Path) -> Result<()> {
    std::fs::create_dir_all(dest.join("toolchains"))?;
    std::fs::create_dir_all(dest.join("platforms"))?;

    // Write toolchains/BUCK with OS-aware system toolchains.
    //
    // This avoids the demo toolchains' Linux `-fuse-ld=lld` default (lld isn't
    // guaranteed to exist) and configures a Windows-friendly linker wrapper to
    // avoid MSVC link.exe's nested response file limitation.
    let toolchains_buck = r#"load("@prelude//toolchains:cxx.bzl", "system_cxx_toolchain")
load("@prelude//toolchains:genrule.bzl", "system_genrule_toolchain")
load(
    "@prelude//toolchains:python.bzl",
    "system_python_bootstrap_toolchain",
    "system_python_toolchain",
)
load("@prelude//toolchains:rust.bzl", "system_rust_toolchain")

# We override the demo toolchains so we can avoid forcing `-fuse-ld=lld`.
# The bundled demo cxx toolchain uses clang++ and adds `-fuse-ld=lld` on Linux,
# but some environments don't have lld installed. We also guard Linux cross
# compiler selection by OS so this file works on macOS/Windows too.
system_cxx_toolchain(
    name = "cxx",
    compiler = select({
        "prelude//os/constraints:linux": select({
            "prelude//cpu/constraints:arm64": "aarch64-linux-gnu-gcc",
            "prelude//cpu/constraints:x86_32": "i686-linux-gnu-gcc",
            "DEFAULT": "gcc",
        }),
        "prelude//os/constraints:macos": "clang",
        "prelude//os/constraints:windows": select({
            "prelude//abi/constraints:gnu": "gcc",
            "DEFAULT": "cl",
        }),
        "DEFAULT": "cc",
    }),
    # Keep `g++` as the C++ compiler on Linux so the prelude doesn't inject
    # `-fuse-ld=lld` (lld isn't guaranteed to exist). Other OSes use their
    # native compilers.
    cxx_compiler = select({
        "prelude//os/constraints:linux": select({
            "prelude//cpu/constraints:arm64": "aarch64-linux-gnu-g++",
            "prelude//cpu/constraints:x86_32": "i686-linux-gnu-g++",
            "DEFAULT": "g++",
        }),
        "prelude//os/constraints:macos": "clang++",
        "prelude//os/constraints:windows": select({
            "prelude//abi/constraints:gnu": "g++",
            "DEFAULT": "cl",
        }),
        "DEFAULT": "c++",
    }),
    linker = select({
        "prelude//os/constraints:linux": select({
            "prelude//cpu/constraints:arm64": "aarch64-linux-gnu-g++",
            "prelude//cpu/constraints:x86_32": "i686-linux-gnu-g++",
            "DEFAULT": "g++",
        }),
        "prelude//os/constraints:macos": "clang++",
        "prelude//os/constraints:windows": select({
            # Use Rust's bundled lld-link instead of MSVC link.exe to avoid
            # link.exe's nested response file limitation (common with Rust + Buck).
            "prelude//abi/constraints:msvc": select({
                "prelude//cpu/constraints:arm64": "toolchains/lld-link-aarch64.bat",
                "prelude//cpu/constraints:x86_32": "toolchains/lld-link-i686.bat",
                "prelude//cpu/constraints:x86_64": "toolchains/lld-link-x86_64.bat",
                "DEFAULT": "toolchains/lld-link.bat",
            }),
            # GNU targets must use a GNU-like driver; lld-link uses MSVC flag syntax.
            "prelude//abi/constraints:gnu": "toolchains/g++-x86_64-gnu-sysroot.bat",
            "DEFAULT": "toolchains/lld-link.bat",
        }),
        "DEFAULT": "c++",
    }),
    # Buck prelude's system C++ toolchain injects `-fuse-ld=lld` into the
    # linker wrapper. Some environments don't ship `ld.lld`,
    # so append `-fuse-ld=bfd` to override it for Linux targets.
    link_flags = select({
        "prelude//os/constraints:linux": ["-fuse-ld=bfd"],
        "DEFAULT": [],
    }),
    visibility = ["PUBLIC"],
)

# Buck prelude only maps a small set of CPU constraints to Rust triples by
# default. We provide an explicit mapping so `--target-platforms` works for
# x86_32 (i686) and OS-specific triples.
system_rust_toolchain(
    name = "rust",
    rustc_target_triple = select({
        "prelude//os/constraints:linux": select({
            "prelude//cpu/constraints:arm64": "aarch64-unknown-linux-gnu",
            "prelude//cpu/constraints:x86_32": "i686-unknown-linux-gnu",
            "DEFAULT": "x86_64-unknown-linux-gnu",
        }),
        "prelude//os/constraints:macos": select({
            "prelude//cpu/constraints:arm64": "aarch64-apple-darwin",
            "DEFAULT": "x86_64-apple-darwin",
        }),
        "prelude//os/constraints:windows": select({
            "prelude//abi/constraints:gnu": "x86_64-pc-windows-gnu",
            "prelude//abi/constraints:msvc": select({
                "prelude//cpu/constraints:arm64": "aarch64-pc-windows-msvc",
                "prelude//cpu/constraints:x86_32": "i686-pc-windows-msvc",
                "DEFAULT": "x86_64-pc-windows-msvc",
            }),
            "DEFAULT": "x86_64-pc-windows-msvc",
        }),
        "DEFAULT": "x86_64-unknown-linux-gnu",
    }),
    visibility = ["PUBLIC"],
)

system_python_bootstrap_toolchain(
    name = "python_bootstrap",
    visibility = ["PUBLIC"],
)

system_python_toolchain(
    name = "python",
    visibility = ["PUBLIC"],
)

system_genrule_toolchain(
    name = "genrule",
    visibility = ["PUBLIC"],
)
"#;
    std::fs::write(dest.join("toolchains/BUCK"), toolchains_buck)?;

    // Windows helper scripts referenced by toolchains/BUCK (safe to vendor on all OSes).
    std::fs::write(
        dest.join("toolchains/lld-link.bat"),
        r#"@echo off
setlocal EnableExtensions

rem Resolve Rust sysroot and host triple, then invoke the bundled lld-link.exe.

for /f "delims=" %%I in ('rustc --print sysroot') do set "SYSROOT=%%I"

set "HOST_TRIPLE="
for /f "tokens=1,* delims=:" %%A in ('rustc -vV ^| findstr /b "host:"') do (
  set "HOST_TRIPLE=%%B"
)
set "HOST_TRIPLE=%HOST_TRIPLE: =%"

if "%HOST_TRIPLE%"=="" (
  echo lld-link.bat: failed to determine Rust host triple via "rustc -vV" 1>&2
  exit /b 1
)

set "LLD_LINK=%SYSROOT%\\lib\\rustlib\\%HOST_TRIPLE%\\bin\\gcc-ld\\lld-link.exe"
if exist "%LLD_LINK%" goto :run

set "LLD_LINK=%SYSROOT%\\bin\\rust-lld.exe"
if exist "%LLD_LINK%" goto :run

echo lld-link.bat: lld-link executable not found under "%SYSROOT%" 1>&2
exit /b 1

:run
"%LLD_LINK%" %*
exit /b %errorlevel%
"#,
    )?;
    std::fs::write(
        dest.join("toolchains/lld-link-x86_64.bat"),
        r#"@echo off
setlocal EnableExtensions

rem Resolve Rust sysroot and host triple, then invoke the bundled lld-link.exe.
rem Adds /machine:X64 unless the caller already specified a machine.

for /f "delims=" %%I in ('rustc --print sysroot') do set "SYSROOT=%%I"

set "HOST_TRIPLE="
for /f "tokens=1,* delims=:" %%A in ('rustc -vV ^| findstr /b "host:"') do (
  set "HOST_TRIPLE=%%B"
)
set "HOST_TRIPLE=%HOST_TRIPLE: =%"

if "%HOST_TRIPLE%"=="" (
  echo lld-link-x86_64.bat: failed to determine Rust host triple via "rustc -vV" 1>&2
  exit /b 1
)

set "LLD_LINK=%SYSROOT%\\lib\\rustlib\\%HOST_TRIPLE%\\bin\\gcc-ld\\lld-link.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

set "LLD_LINK=%SYSROOT%\\bin\\rust-lld.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

echo lld-link-x86_64.bat: lld-link executable not found under "%SYSROOT%" 1>&2
exit /b 1

:maybe_add_machine
set "ADD_MACHINE=1"
for %%A in (%*) do (
  echo %%~A | findstr /I /B "/machine:" "-machine:" >nul && set "ADD_MACHINE=0"
)

if "%ADD_MACHINE%"=="1" (
  "%LLD_LINK%" /machine:X64 %*
) else (
  "%LLD_LINK%" %*
)
exit /b %errorlevel%
"#,
    )?;
    std::fs::write(
        dest.join("toolchains/lld-link-i686.bat"),
        r#"@echo off
setlocal EnableExtensions

rem Resolve Rust sysroot and host triple, then invoke the bundled lld-link.exe.
rem Adds /machine:X86 unless the caller already specified a machine.

for /f "delims=" %%I in ('rustc --print sysroot') do set "SYSROOT=%%I"

set "HOST_TRIPLE="
for /f "tokens=1,* delims=:" %%A in ('rustc -vV ^| findstr /b "host:"') do (
  set "HOST_TRIPLE=%%B"
)
set "HOST_TRIPLE=%HOST_TRIPLE: =%"

if "%HOST_TRIPLE%"=="" (
  echo lld-link-i686.bat: failed to determine Rust host triple via "rustc -vV" 1>&2
  exit /b 1
)

set "LLD_LINK=%SYSROOT%\\lib\\rustlib\\%HOST_TRIPLE%\\bin\\gcc-ld\\lld-link.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

set "LLD_LINK=%SYSROOT%\\bin\\rust-lld.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

echo lld-link-i686.bat: lld-link executable not found under "%SYSROOT%" 1>&2
exit /b 1

:maybe_add_machine
set "ADD_MACHINE=1"
for %%A in (%*) do (
  echo %%~A | findstr /I /B "/machine:" "-machine:" >nul && set "ADD_MACHINE=0"
)

if "%ADD_MACHINE%"=="1" (
  "%LLD_LINK%" /machine:X86 %*
) else (
  "%LLD_LINK%" %*
)
exit /b %errorlevel%
"#,
    )?;
    std::fs::write(
        dest.join("toolchains/lld-link-aarch64.bat"),
        r#"@echo off
setlocal EnableExtensions

rem Resolve Rust sysroot and host triple, then invoke the bundled lld-link.exe.
rem Adds /machine:ARM64 unless the caller already specified a machine.

for /f "delims=" %%I in ('rustc --print sysroot') do set "SYSROOT=%%I"

set "HOST_TRIPLE="
for /f "tokens=1,* delims=:" %%A in ('rustc -vV ^| findstr /b "host:"') do (
  set "HOST_TRIPLE=%%B"
)
set "HOST_TRIPLE=%HOST_TRIPLE: =%"

if "%HOST_TRIPLE%"=="" (
  echo lld-link-aarch64.bat: failed to determine Rust host triple via "rustc -vV" 1>&2
  exit /b 1
)

set "LLD_LINK=%SYSROOT%\\lib\\rustlib\\%HOST_TRIPLE%\\bin\\gcc-ld\\lld-link.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

set "LLD_LINK=%SYSROOT%\\bin\\rust-lld.exe"
if exist "%LLD_LINK%" goto :maybe_add_machine

echo lld-link-aarch64.bat: lld-link executable not found under "%SYSROOT%" 1>&2
exit /b 1

:maybe_add_machine
set "ADD_MACHINE=1"
for %%A in (%*) do (
  echo %%~A | findstr /I /B "/machine:" "-machine:" >nul && set "ADD_MACHINE=0"
)

if "%ADD_MACHINE%"=="1" (
  "%LLD_LINK%" /machine:ARM64 %*
) else (
  "%LLD_LINK%" %*
)
exit /b %errorlevel%
"#,
    )?;
    std::fs::write(
        dest.join("toolchains/g++-x86_64-gnu-sysroot.bat"),
        r#"@echo off
setlocal EnableExtensions

rem Add Rust's GNU sysroot "self-contained" libs to the search path.
rem This provides libgcc_eh.a (and friends) even when the system MinGW is incomplete.

for /f "delims=" %%I in ('rustc +stable-x86_64-pc-windows-gnu --print sysroot') do set "SYSROOT=%%I"

set "SELF_CONTAINED=%SYSROOT%\\lib\\rustlib\\x86_64-pc-windows-gnu\\lib\\self-contained"
if not exist "%SELF_CONTAINED%" (
  echo g++-gnu-sysroot.bat: self-contained dir not found: "%SELF_CONTAINED%" 1>&2
  exit /b 1
)

g++ -L"%SELF_CONTAINED%" %*
exit /b %errorlevel%
"#,
    )?;

    // Write platforms/BUCK with a Tier1-ish set of Rust triples.
    let mut platforms = std::fs::File::create(dest.join("platforms/BUCK"))?;
    writeln!(
        platforms,
        "# Target platforms expressed using Rust-style triples."
    )?;
    writeln!(
        platforms,
        "# These are intended for `--target-platforms` and to make `select()`s in"
    )?;
    writeln!(
        platforms,
        "# buckal-generated rules match on OS/CPU/ABI constraints."
    )?;
    writeln!(platforms)?;

    let mut write_platform = |name: &str, constraints: &[&str]| -> std::io::Result<()> {
        writeln!(platforms, "platform(")?;
        writeln!(platforms, "    name = \"{}\",", name)?;
        writeln!(platforms, "    constraint_values = [")?;
        for c in constraints {
            writeln!(platforms, "        \"{}\",", c)?;
        }
        writeln!(platforms, "    ],")?;
        writeln!(platforms, "    visibility = [\"PUBLIC\"],")?;
        writeln!(platforms, ")")?;
        writeln!(platforms)?;
        Ok(())
    };

    // macOS
    write_platform(
        "aarch64-apple-darwin",
        &[
            "prelude//os/constraints:macos",
            "prelude//cpu/constraints:arm64",
        ],
    )?;

    // Windows MSVC
    write_platform(
        "aarch64-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:arm64",
            "prelude//abi/constraints:msvc",
        ],
    )?;
    write_platform(
        "x86_64-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:msvc",
        ],
    )?;
    write_platform(
        "i686-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_32",
            "prelude//abi/constraints:msvc",
        ],
    )?;

    // Windows GNU (MinGW)
    write_platform(
        "x86_64-pc-windows-gnu",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:gnu",
        ],
    )?;

    // Linux GNU
    write_platform(
        "aarch64-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:arm64",
            "prelude//abi/constraints:gnu",
        ],
    )?;
    write_platform(
        "x86_64-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:gnu",
        ],
    )?;
    write_platform(
        "i686-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:x86_32",
            "prelude//abi/constraints:gnu",
        ],
    )?;

    Ok(())
}

pub fn fetch_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let buckal_section = buckconfig.get_section_mut("external_cell_buckal");
    buckal_section.clear();
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

#[derive(Deserialize)]
struct GithubCommit {
    sha: String,
}

pub fn fetch() -> Result<String> {
    let url = format!(
        "https://api.github.com/repos/{}/commits",
        crate::BUCKAL_BUNDLES_REPO
    );
    buckal_log!(
        "Fetching",
        format!("https://github.com/{}", crate::BUCKAL_BUNDLES_REPO)
    );
    let client = Client::new();
    let response: Vec<GithubCommit> = client
        .get(&url)
        .header(USER_AGENT, user_agent())
        .query(&[("per_page", "1")])
        .send()?
        .json()?;
    Ok(response[0].sha.clone())
}
