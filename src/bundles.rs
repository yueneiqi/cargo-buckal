use std::collections::HashMap;
use std::io::Write;
use std::result::Result::Ok;

use anyhow::Result;
use reqwest::blocking::Client;
use reqwest::header::USER_AGENT;
use serde::Deserialize;

use crate::{buckal_log, buckal_warn, user_agent};

type Section = String;
type Lines = Vec<String>;

#[derive(Default)]
struct BuckConfig {
    section_order: Vec<Section>,
    sections: HashMap<Section, Lines>,
}

impl BuckConfig {
    pub fn load(path: &std::path::Path) -> std::io::Result<Self> {
        let contents = std::fs::read_to_string(path)?;
        Ok(Self::parse(contents))
    }

    pub fn save(&self, path: &std::path::Path) -> std::io::Result<()> {
        std::fs::write(path, self.serialize())?;
        Ok(())
    }

    pub fn get_section_mut(&mut self, section: &str) -> &mut Lines {
        self.sections.entry(section.to_string()).or_default()
    }

    fn new_section_after(&mut self, after_section: &str, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());

        if let Some(pos) = self.section_order.iter().position(|s| s == after_section) {
            self.section_order
                .insert(pos + 1, new_section_name.to_owned());
        } else {
            self.section_order.push(new_section_name.to_owned());
        }

        self.sections.entry(new_section_name).or_default()
    }

    fn new_section(&mut self, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());
        self.section_order.push(new_section_name.to_owned());

        self.sections.entry(new_section_name).or_default()
    }

    fn parse(contents: String) -> BuckConfig {
        let lines: Vec<String> = contents.lines().map(|s| s.to_string()).collect();

        let mut config = BuckConfig::default();
        let mut current_section: Option<String> = None;

        for line in lines {
            let trimmed = line.trim();
            if trimmed.starts_with('[') && trimmed.ends_with(']') {
                let section_name = trimmed[1..trimmed.len() - 1].to_string();
                config.section_order.push(section_name.clone());
                current_section = Some(section_name);
            } else if trimmed.starts_with('#') {
                continue;
            } else if !line.is_empty()
                && let Some(section) = &current_section
            {
                config
                    .sections
                    .entry(section.clone())
                    .or_default()
                    .push(line);
            }
        }
        config
    }

    fn serialize(&self) -> String {
        let mut output = String::new();

        for section in &self.section_order {
            output.push('[');
            output.push_str(section);
            output.push_str("]\n");
            if let Some(lines) = self.sections.get(section) {
                for line in lines {
                    output.push_str(line);
                    output.push('\n');
                }
                output.push('\n');
            }
        }
        output.pop();

        output
    }
}

pub fn init_modifier(dest: &std::path::Path) -> Result<()> {
    let mut package_file = std::fs::File::create(dest.join("PACKAGE"))?;

    writeln!(package_file, "# @generated by `cargo buckal`")?;
    writeln!(package_file)?;
    writeln!(
        package_file,
        "load(\"@prelude//cfg/modifier:set_cfg_modifiers.bzl\", \"set_cfg_modifiers\")"
    )?;
    writeln!(
        package_file,
        "load(\"@prelude//rust:with_workspace.bzl\", \"with_rust_workspace\")"
    )?;
    writeln!(
        package_file,
        "load(\"@buckal//config:set_cfg_constructor.bzl\", \"set_cfg_constructor\")"
    )?;
    writeln!(package_file)?;
    writeln!(package_file, "ALIASES = {{")?;
    writeln!(
        package_file,
        "    \"debug\": \"buckal//config/mode:debug\","
    )?;
    writeln!(
        package_file,
        "    \"release\": \"buckal//config/mode:release\","
    )?;
    writeln!(package_file, "}}")?;
    writeln!(package_file, "set_cfg_constructor(aliases = ALIASES)")?;
    writeln!(package_file)?;
    writeln!(package_file, "set_cfg_modifiers(")?;
    writeln!(package_file, "    cfg_modifiers = [")?;
    writeln!(package_file, "        \"buckal//config/mode:debug\",")?;
    writeln!(package_file, "    ],")?;
    writeln!(package_file, ")")?;

    Ok(())
}

pub fn init_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let cells = buckconfig.get_section_mut("cells");
    upsert_kv_line(cells, "buckal", "buckal");
    let external_cells = buckconfig.get_section_mut("external_cells");
    upsert_kv_line(external_cells, "buckal", "git");
    let buckal_section =
        buckconfig.new_section_after("external_cells", "external_cell_buckal".to_owned());
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    let project = buckconfig.new_section("project".to_owned());
    project.push("  ignore = .git .buckal buck-out target".to_owned());
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

fn upsert_kv_line(lines: &mut Lines, key: &str, value: &str) {
    let prefix = format!("{key} =");
    let replacement = format!("  {key} = {value}");
    if let Some(pos) = lines
        .iter()
        .position(|line| line.trim_start().starts_with(&prefix))
    {
        lines[pos] = replacement;
    } else {
        lines.push(replacement);
    }
}

pub fn fetch_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let buckal_section = buckconfig.get_section_mut("external_cell_buckal");
    buckal_section.clear();
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

#[derive(Deserialize)]
struct GithubCommit {
    sha: String,
}

pub fn fetch() -> Result<String> {
    let url = format!(
        "https://api.github.com/repos/{}/commits",
        crate::BUCKAL_BUNDLES_REPO
    );
    buckal_log!(
        "Fetching",
        format!("https://github.com/{}", crate::BUCKAL_BUNDLES_REPO)
    );
    let client = Client::new();
    let response: Vec<GithubCommit> = client
        .get(&url)
        .header(USER_AGENT, user_agent())
        .query(&[("per_page", "1")])
        .send()?
        .json()?;
    Ok(response[0].sha.clone())
}
