use std::collections::HashMap;
use std::io::Write;
use std::result::Result::Ok;

use anyhow::Result;
use reqwest::blocking::Client;
use reqwest::header::USER_AGENT;
use serde::Deserialize;

use crate::{buckal_log, buckal_warn, user_agent};

type Section = String;
type Lines = Vec<String>;

#[derive(Default)]
struct BuckConfig {
    section_order: Vec<Section>,
    sections: HashMap<Section, Lines>,
}

impl BuckConfig {
    pub fn load(path: &std::path::Path) -> std::io::Result<Self> {
        let contents = std::fs::read_to_string(path)?;
        Ok(Self::parse(contents))
    }

    pub fn save(&self, path: &std::path::Path) -> std::io::Result<()> {
        std::fs::write(path, self.serialize())?;
        Ok(())
    }

    pub fn get_section_mut(&mut self, section: &str) -> &mut Lines {
        self.sections.entry(section.to_string()).or_default()
    }

    fn new_section_after(&mut self, after_section: &str, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());

        if let Some(pos) = self.section_order.iter().position(|s| s == after_section) {
            self.section_order
                .insert(pos + 1, new_section_name.to_owned());
        } else {
            self.section_order.push(new_section_name.to_owned());
        }

        self.sections.entry(new_section_name).or_default()
    }

    fn new_section(&mut self, new_section_name: String) -> &mut Lines {
        self.sections.insert(new_section_name.clone(), Vec::new());
        self.section_order.push(new_section_name.to_owned());

        self.sections.entry(new_section_name).or_default()
    }

    fn parse(contents: String) -> BuckConfig {
        let lines: Vec<String> = contents.lines().map(|s| s.to_string()).collect();

        let mut config = BuckConfig::default();
        let mut current_section: Option<String> = None;

        for line in lines {
            let trimmed = line.trim();
            if trimmed.starts_with('[') && trimmed.ends_with(']') {
                let section_name = trimmed[1..trimmed.len() - 1].to_string();
                config.section_order.push(section_name.clone());
                current_section = Some(section_name);
            } else if trimmed.starts_with('#') {
                continue;
            } else if !line.is_empty()
                && let Some(section) = &current_section
            {
                config
                    .sections
                    .entry(section.clone())
                    .or_default()
                    .push(line);
            }
        }
        config
    }

    fn serialize(&self) -> String {
        let mut output = String::new();

        for section in &self.section_order {
            output.push('[');
            output.push_str(section);
            output.push_str("]\n");
            if let Some(lines) = self.sections.get(section) {
                for line in lines {
                    output.push_str(line);
                    output.push('\n');
                }
                output.push('\n');
            }
        }
        output.pop();

        output
    }
}

pub fn init_modifier(dest: &std::path::Path) -> Result<()> {
    let mut package_file = std::fs::File::create(dest.join("PACKAGE"))?;

    writeln!(package_file, "# @generated by `cargo buckal`")?;
    writeln!(package_file)?;
    writeln!(
        package_file,
        "load(\"@prelude//cfg/modifier:set_cfg_modifiers.bzl\", \"set_cfg_modifiers\")"
    )?;
    writeln!(
        package_file,
        "load(\"@prelude//rust:with_workspace.bzl\", \"with_rust_workspace\")"
    )?;
    writeln!(
        package_file,
        "load(\"@buckal//config:set_cfg_constructor.bzl\", \"set_cfg_constructor\")"
    )?;
    writeln!(package_file)?;
    writeln!(package_file, "ALIASES = {{")?;
    writeln!(
        package_file,
        "    \"debug\": \"buckal//config/mode:debug\","
    )?;
    writeln!(
        package_file,
        "    \"release\": \"buckal//config/mode:release\","
    )?;
    writeln!(package_file, "}}")?;
    writeln!(package_file, "set_cfg_constructor(aliases = ALIASES)")?;
    writeln!(package_file)?;
    writeln!(package_file, "set_cfg_modifiers(")?;
    writeln!(package_file, "    cfg_modifiers = [")?;
    writeln!(package_file, "        \"buckal//config/mode:debug\",")?;
    writeln!(package_file, "    ],")?;
    writeln!(package_file, ")")?;

    Ok(())
}

pub fn init_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let cells = buckconfig.get_section_mut("cells");
    cells.push("  buckal = buckal".to_owned());
    let external_cells = buckconfig.get_section_mut("external_cells");
    external_cells.push("  buckal = git".to_owned());
    let buckal_section =
        buckconfig.new_section_after("external_cells", "external_cell_buckal".to_owned());
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    let project = buckconfig.new_section("project".to_owned());
    project.push("  ignore = .git .buckal buck-out target".to_owned());
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

/// Initialize platform-related skeleton files after `buck2 init`.
///
/// Buck2's demo toolchains on Linux inject `-fuse-ld=lld`, which breaks
/// environments without lld and causes cross-arch linkers to default to host
/// tools. We overwrite `toolchains/BUCK` on Linux with explicit system
/// toolchains and write a minimal `platforms/BUCK` for common Rust triples on
/// the host OS.
pub fn init_platform_files(dest: &std::path::Path) -> Result<()> {
    let os = std::env::consts::OS;

    // Ensure directories exist.
    std::fs::create_dir_all(dest.join("toolchains"))?;
    std::fs::create_dir_all(dest.join("platforms"))?;

    // Overwrite toolchains only on Linux to avoid lld demo toolchain issues.
    if os == "linux" {
        let mut toolchains = std::fs::File::create(dest.join("toolchains/BUCK"))?;
        writeln!(toolchains, "load(\"@prelude//toolchains:cxx.bzl\", \"system_cxx_toolchain\")")?;
        writeln!(toolchains, "load(\"@prelude//toolchains:genrule.bzl\", \"system_genrule_toolchain\")")?;
        writeln!(
            toolchains,
            "load(\n    \"@prelude//toolchains:python.bzl\",\n    \"system_python_bootstrap_toolchain\",\n    \"system_python_toolchain\",\n)"
        )?;
        writeln!(toolchains, "load(\"@prelude//toolchains:rust.bzl\", \"system_rust_toolchain\")")?;
        writeln!(toolchains)?;
        writeln!(
            toolchains,
            "# We override the demo toolchains so we can avoid forcing `-fuse-ld=lld`."
        )?;
        writeln!(
            toolchains,
            "# The bundled demo cxx toolchain uses clang++ and adds `-fuse-ld=lld` on Linux."
        )?;
        writeln!(
            toolchains,
            "# Using the system GCC/G++ tools keeps linker flags empty and fixes rust linking."
        )?;
        writeln!(toolchains, "system_cxx_toolchain(")?;
        writeln!(toolchains, "    name = \"cxx\",")?;
        writeln!(toolchains, "    compiler = select({{")?;
        writeln!(
            toolchains,
            "        \"prelude//cpu/constraints:arm64\": \"aarch64-linux-gnu-gcc\","
        )?;
        writeln!(toolchains, "        \"DEFAULT\": \"gcc\",")?;
        writeln!(toolchains, "    }}),")?;
        writeln!(
            toolchains,
            "    # Keep `g++` as the C++ compiler even for arm64 so the prelude"
        )?;
        writeln!(
            toolchains,
            "    # doesn't inject `-fuse-ld=lld` (lld isn't available here)."
        )?;
        writeln!(toolchains, "    cxx_compiler = \"g++\",")?;
        writeln!(toolchains, "    linker = select({{")?;
        writeln!(
            toolchains,
            "        \"prelude//cpu/constraints:arm64\": \"aarch64-linux-gnu-g++\","
        )?;
        writeln!(toolchains, "        \"DEFAULT\": \"g++\",")?;
        writeln!(toolchains, "    }}),")?;
        writeln!(toolchains, "    visibility = [\"PUBLIC\"],")?;
        writeln!(toolchains, ")")?;
        writeln!(toolchains)?;
        writeln!(toolchains, "system_rust_toolchain(")?;
        writeln!(toolchains, "    name = \"rust\",")?;
        writeln!(toolchains, "    visibility = [\"PUBLIC\"],")?;
        writeln!(toolchains, ")")?;
        writeln!(toolchains)?;
        writeln!(toolchains, "system_python_bootstrap_toolchain(")?;
        writeln!(toolchains, "    name = \"python_bootstrap\",")?;
        writeln!(toolchains, "    visibility = [\"PUBLIC\"],")?;
        writeln!(toolchains, ")")?;
        writeln!(toolchains)?;
        writeln!(toolchains, "system_python_toolchain(")?;
        writeln!(toolchains, "    name = \"python\",")?;
        writeln!(toolchains, "    visibility = [\"PUBLIC\"],")?;
        writeln!(toolchains, ")")?;
        writeln!(toolchains)?;
        writeln!(toolchains, "system_genrule_toolchain(")?;
        writeln!(toolchains, "    name = \"genrule\",")?;
        writeln!(toolchains, "    visibility = [\"PUBLIC\"],")?;
        writeln!(toolchains, ")")?;
    }

    // Write platforms/BUCK with a Tier1-ish set of Rust triples.
    let mut platforms = std::fs::File::create(dest.join("platforms/BUCK"))?;
    writeln!(platforms, "# Target platforms expressed using Rust-style triples.")?;
    writeln!(
        platforms,
        "# These are intended for `--target-platforms` and to make `select()`s in"
    )?;
    writeln!(
        platforms,
        "# buckal-generated rules match on OS/CPU/ABI constraints."
    )?;
    writeln!(platforms)?;

    let mut write_platform = |name: &str, constraints: &[&str]| -> std::io::Result<()> {
        writeln!(platforms, "platform(")?;
        writeln!(platforms, "    name = \"{}\",", name)?;
        writeln!(platforms, "    constraint_values = [")?;
        for c in constraints {
            writeln!(platforms, "        \"{}\",", c)?;
        }
        writeln!(platforms, "    ],")?;
        writeln!(platforms, "    visibility = [\"PUBLIC\"],")?;
        writeln!(platforms, ")")?;
        writeln!(platforms)?;
        Ok(())
    };

    // macOS
    write_platform(
        "aarch64-apple-darwin",
        &[
            "prelude//os/constraints:macos",
            "prelude//cpu/constraints:arm64",
        ],
    )?;

    // Windows MSVC
    write_platform(
        "aarch64-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:arm64",
            "prelude//abi/constraints:msvc",
        ],
    )?;
    write_platform(
        "x86_64-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:msvc",
        ],
    )?;
    write_platform(
        "i686-pc-windows-msvc",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_32",
            "prelude//abi/constraints:msvc",
        ],
    )?;

    // Windows GNU (MinGW)
    write_platform(
        "x86_64-pc-windows-gnu",
        &[
            "prelude//os/constraints:windows",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:gnu",
        ],
    )?;

    // Linux GNU
    write_platform(
        "aarch64-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:arm64",
            "prelude//abi/constraints:gnu",
        ],
    )?;
    write_platform(
        "x86_64-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:x86_64",
            "prelude//abi/constraints:gnu",
        ],
    )?;
    write_platform(
        "i686-unknown-linux-gnu",
        &[
            "prelude//os/constraints:linux",
            "prelude//cpu/constraints:x86_32",
            "prelude//abi/constraints:gnu",
        ],
    )?;

    Ok(())
}

pub fn fetch_buckal_cell(dest: &std::path::Path) -> Result<()> {
    let mut buckconfig = BuckConfig::load(&dest.join(".buckconfig"))?;
    let buckal_section = buckconfig.get_section_mut("external_cell_buckal");
    buckal_section.clear();
    buckal_section.push(format!(
        "  git_origin = https://github.com/{}",
        crate::BUCKAL_BUNDLES_REPO
    ));
    let commit_hash = match fetch() {
        Ok(hash) => hash,
        Err(e) => {
            buckal_warn!(
                "Failed to fetch latest bundle hash ({}), using default hash instead.",
                e
            );
            crate::DEFAULT_BUNDLE_HASH.to_string()
        }
    };
    buckal_section.push(format!("  commit_hash = {}", commit_hash));
    buckconfig.save(&dest.join(".buckconfig"))?;

    Ok(())
}

#[derive(Deserialize)]
struct GithubCommit {
    sha: String,
}

pub fn fetch() -> Result<String> {
    let url = format!(
        "https://api.github.com/repos/{}/commits",
        crate::BUCKAL_BUNDLES_REPO
    );
    buckal_log!(
        "Fetching",
        format!("https://github.com/{}", crate::BUCKAL_BUNDLES_REPO)
    );
    let client = Client::new();
    let response: Vec<GithubCommit> = client
        .get(&url)
        .header(USER_AGENT, user_agent())
        .query(&[("per_page", "1")])
        .send()?
        .json()?;
    Ok(response[0].sha.clone())
}
